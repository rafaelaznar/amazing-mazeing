<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Amazing Mazeing - Algorithm Visualizer</title>
    <meta name="description" content="Explore and compare maze solving algorithms: BFS, DFS, and FLOOD.">
    <meta name="author" content="Rafael Aznar">
    <meta name="robots" content="index, follow">
    <link rel="icon"
        href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='0.9em' font-size='90'%3ERM%3C/text%3E%3C/svg%3E">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* CSS Reset */
        *,
        *::before,
        *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        /* Variables */
        :root {
            --primary-color: #3498db;
            /* Blue */
            --primary-dark: #2980b9;
            --secondary-color: #e67e22;
            /* Orange */
            --secondary-dark: #d35400;
            --text-color: #2c3e50;
            /* Dark gray */
            --text-light: #7f8c8d;
            --background: #ecf0f1;
            /* Light gray */
            --white: #ffffff;
            --hot-yellow: #f1c40f;
            --hot-green: #2ecc71;
            --hot-red: #e74c3c;
            --hot-blue: #3498db;

            --maze-wall-color: black;
            --maze-path-color: white;
            --maze-start-color: lightblue;
            --maze-end-color: lightgreen;
            --maze-explored-color: yellow;
            --maze-backtrack-color: lightblue;
            --maze-current-color: lightsalmon;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--background);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            margin: 0;
            padding: 0;
        }

        /* --- General Styles --- */
        h1 {
            color: var(--primary-color);
            text-align: center;
            margin-bottom: 0.5em;
            font-size: 2.5em;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2em;
            }
        }

        h2 {
            color: var(--text-light);
            text-align: center;
            margin-bottom: 1em;
            font-size: 1.2em;
            font-weight: normal;
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 95%;
            max-width: 1200px;
            margin-top: 1em;
        }

        .settings-group {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 1.5em;
            width: 100%;
            gap: 1em;
            flex-wrap: wrap;
        }

        @media (max-width: 768px) {
            .settings-group {
                flex-direction: column;
            }
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-right: 1em;
            margin-bottom: 0;
        }

        .control-group label {
            margin-bottom: 0.5em;
            color: var(--text-color);
            font-weight: 500;
            font-size: 0.9em;
        }

        /* --- Range Slider Styles --- */
        input[type="range"] {

            width: 200px;
            height: 30px;
            border-radius: 5px;
            background: var(--background);
            outline: none;
            -webkit-transition: .2s;
            transition: opacity .2s;
        }


        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
        }

        input[type="range"]:focus::-webkit-slider-thumb {
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.3);
        }

        input[type="range"]:focus::-moz-range-thumb {
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.3);
        }

        /* --- Select Styles --- */
        #mode_selector {
            position: relative;
            user-select: none;
            flex-grow: 1;
            min-width: 200px;
            padding: 0.5em 1em;
            border: 2px solid #c5c5c5;
            cursor: pointer;
            border-radius: 5px;
        }

        #mode_selector:hover,
        #mode_selector:focus-within {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }

        /* --- Button Styles --- */
        .button-group {
            display: flex;
            justify-content: center;
            margin-bottom: 1.5em;
            width: 100%;
            gap: 1em;
            flex-wrap: wrap;
        }

        .app-button {
            padding: 0.75em 1.5em;
            border: none;
            border-radius: 5px;
            color: var(--white);
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.3s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            width: 150px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            text-decoration: none;
        }

        .app-button:hover {
            filter: brightness(110%);
        }

        .app-button:disabled {
            background-color: #bdc3c7;
            /* Gray */
            cursor: not-allowed;
            opacity: 0.6;
            box-shadow: none;
        }

        .app-button.hot-yellow {
            background-color: var(--hot-yellow);
        }

        .app-button.hot-yellow:hover {
            background-color: #f0b207;
        }

        .app-button.hot-green {
            background-color: var(--hot-green);
        }

        .app-button.hot-green:hover {
            background-color: #27ae60;
        }

        .app-button.hot-red {
            background-color: var(--hot-red);
        }

        .app-button.hot-red:hover {
            background-color: #c0392b;
        }

        .app-button.hot-blue {
            background-color: var(--hot-blue);
        }

        .app-button.hot-blue:hover {
            background-color: #217dbb;
        }

        /* --- Maze Styles --- */
        #maze {
            /* border: 2px solid #34495e; */
            /* Dark gray border */
            margin-bottom: 2em;
            background-color: var(--maze-path-color);
            /* width and height will be set in JS to ensure square */
        }

        @media (max-width: 768px) {
            #maze {
                width: 95%;
                height: auto;
                aspect-ratio: 1 / 1;
            }
        }

        .line {
            width: 30%;
            height: 3px;
            background-color: var(--text-light);
            margin: 0.5em 0;
        }

        .footer {
            margin: 1em 0 3em 0;
            text-align: center;
            font-size: 1.3em;
            color: var(--text-light);
        }

        /* --- Algorithm Info Styles --- */
        .algorithm-info {
            background-color: var(--white);
            border-radius: 8px;
            padding: 1.5em;
            margin-bottom: 2em;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            max-width: 800px;
            width: 100%;
        }

        .algorithm-info h3 {
            color: var(--primary-color);
            margin-bottom: 0.8em;
            font-size: 1.3em;
        }

        .algorithm-info p {
            color: var(--text-color);
            line-height: 1.6;
            margin-bottom: 0.5em;
        }

        .algorithm-info ul {
            margin-left: 1.5em;
            color: var(--text-color);
            line-height: 1.8;
        }

        .algorithm-info .algo-highlight {
            font-weight: 600;
            color: var(--primary-dark);
        }

        .results-container {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            width: 100%;
            margin-bottom: 2em;
        }

        .result-card {
            background-color: #bdc3c7;
            padding: 15px 20px;
            border-radius: 8px;
            min-width: 150px;
            text-align: center;
        }

        .result-card h3 {
            color: #747474;
            font-size: 0.9em;
            margin-bottom: 0.5em;
            font-weight: 500;
        }

        .result-card .result-value {
            font-size: 3em;
            color: var(--primary-color);
            font-weight: bold;
        }

        @media (max-width: 768px) {
            .algorithm-info {
                padding: 1em;
            }
            
            .result-card .result-value {
                font-size: 2.5em;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1 id="main_title">Amazing Mazeing</h1>
        <h2 id="subtitle">Visualize & Compare Pathfinding Algorithms</h2>

        <div class="settings-group" id="settings_group">
            <div class="control-group">
                <label for="height_slider">Maze Size</label>
                <input type="range" id="height_slider" min="35" max="95" value="45" step="10">
                <span id="height_value">450 cells</span>
            </div>
            <div class="control-group">
                <label for="mode_selector">Algorithm</label>
                <div id="mode_selector_options">
                    <select id="mode_selector">
                        <option value="bfs">BFS - Breadth First Search</option>
                        <option value="dfs">DFS - Depth First Search</option>
                        <option value="astar">A* - A* (Manhattan)</option>
                        <option value="random">Random Greedy - Greedy Best-First (random tie-break)</option>
                        <option value="flood">FLOOD - BFS with Path</option>
                    </select>
                </div>
            </div>
            <div class="control-group">
                <label for="speed_slider">Animation Speed</label>
                <input type="range" id="speed_slider" min="1" max="1001" value="1" step="100">
                <span id="speed_value">1 ms</span>
            </div>



        </div>

        <div class="button-group" id="button_group">
            <button class="app-button hot-yellow" id="maze_creation_button">Generate Maze</button>
            <button class="app-button hot-green" id="start_button" disabled>Start Search</button>
            <button class="app-button hot-red" id="stop_button" disabled>Pause</button>
            <button class="app-button hot-blue" id="reset_search_button" disabled>Clear Search</button>
        </div>

        <!-- Algorithm Information -->
        <div class="algorithm-info" id="algorithm_info">
            <h3>Select an algorithm to see its description</h3>
            <p>Choose an algorithm from the dropdown above and learn how it explores the maze to find the path from start (cyan) to end (green).</p>
        </div>

        <canvas id="maze"></canvas>

        <!-- Results Display -->
        <div class="results-container" id="results_pane" style="display:none;">
            <div class="result-card">
                <h3>Path Length</h3>
                <div class="result-value" id="solution_length_number">-</div>
            </div>
            <div class="result-card">
                <h3>Cells Explored</h3>
                <div class="result-value" id="cells_explored">-</div>
            </div>
            <div class="result-card">
                <h3>Time (ms)</h3>
                <div class="result-value" id="time_ms">-</div>
            </div>
        </div>

        <!-- line -->
        <div class="line"></div>
        <div class="footer">
            <p>Created by Rafael Aznar (MIT License)</p>
            <p>GitHub: <a href="https://github.com/rafaelaznar/amazing-mazeing" target="_blank" style="color: var(--primary-color);">amazing-mazeing</a></p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Get HTML Elements ---
            const mazeCanvas = document.getElementById('maze');
            const heightSlider = document.getElementById('height_slider');
            const heightValueDisplay = document.getElementById('height_value');
            const speedSlider = document.getElementById('speed_slider');
            const speedValueDisplay = document.getElementById('speed_value');
            const modeSelector = document.getElementById('mode_selector');
            const modeSelectorWrapper = document.getElementById('mode_selector_wrapper');
            const modeSelectorTrigger = document.getElementById('mode_selector_trigger');
            const modeSelectorOptions = document.getElementById('mode_selector_options');
            const mazeCreationButton = document.getElementById('maze_creation_button');
            const startButton = document.getElementById('start_button');
            const stopButton = document.getElementById('stop_button');
            // The original "New Maze" button was removed (we already have Generate Maze).
            // Keep a `resetButton` alias pointing to the Generate Maze button so existing code
            // that enables/disables `resetButton` continues to work. We want the
            // Generate Maze button to always be active, so wrap the element in a Proxy
            // that ignores attempts to disable it (assigning disabled = true).
            mazeCreationButton.disabled = false; // ensure enabled at start
            const resetButton = new Proxy(mazeCreationButton, {
                set(target, prop, value) {
                    if (prop === 'disabled') {
                        // Allow disabling only if a search is in progress
                        if (value === true && isSearching) {
                            target.disabled = true;
                        } else if (value === false) {
                            target.disabled = false;
                        }
                        // otherwise ignore attempts to disable when not searching
                        return true;
                    }
                    try { target[prop] = value; } catch (e) { /* ignore */ }
                    return true;
                },
                get(target, prop) {
                    const v = target[prop];
                    return typeof v === 'function' ? v.bind(target) : v;
                }
            });
            // Also guard against code that uses setAttribute('disabled', ...) or similar by
            // observing attribute changes and re-enabling the button immediately.
            const _mo = new MutationObserver(() => {
                // If some code sets the disabled attribute, allow it only when a search is running
                if (!isSearching) {
                    if (mazeCreationButton.disabled) mazeCreationButton.disabled = false;
                    if (mazeCreationButton.hasAttribute && mazeCreationButton.hasAttribute('disabled')) {
                        mazeCreationButton.removeAttribute('disabled');
                    }
                }
            });
            _mo.observe(mazeCreationButton, { attributes: true, attributeFilter: ['disabled'] });
            const resetSearchButton = document.getElementById('reset_search_button');
            const container = document.querySelector('.container');
            const resultsPane = document.getElementById('results_pane');
            const solutionLengthNumber = document.getElementById("solution_length_number");
            const cellsExploredDisplay = document.getElementById("cells_explored");
            const algorithmInfo = document.getElementById('algorithm_info');
            
            // Algorithm descriptions
            const algorithmDescriptions = {
                'bfs': {
                    title: 'BFS - Breadth First Search',
                    description: 'BFS explores the maze level by level, visiting all neighbors at the current distance before moving further.',
                    features: [
                        '<span class="algo-highlight">Guarantees shortest path:</span> Always finds the solution with minimum steps',
                        '<span class="algo-highlight">Strategy:</span> Uses a queue (FIFO - First In First Out)',
                        '<span class="algo-highlight">Memory:</span> Moderate - stores all nodes at current level',
                        '<span class="algo-highlight">Best for:</span> Finding optimal paths in unweighted graphs'
                    ]
                },
                'dfs': {
                    title: 'DFS - Depth First Search',
                    description: 'DFS explores as far as possible along each branch before backtracking, diving deep into the maze.',
                    features: [
                        '<span class="algo-highlight">Path quality:</span> May not find the shortest path',
                        '<span class="algo-highlight">Strategy:</span> Uses recursion/stack (LIFO - Last In First Out)',
                        '<span class="algo-highlight">Memory:</span> Lower average usage than BFS',
                        '<span class="algo-highlight">Best for:</span> Exploring all possibilities, puzzle solving'
                    ]
                },
                'flood': {
                    title: 'FLOOD - BFS with Path Storage',
                    description: 'Similar to BFS but stores the complete path at each step, making path reconstruction immediate.',
                    features: [
                        '<span class="algo-highlight">Guarantees shortest path:</span> Yes, like standard BFS',
                        '<span class="algo-highlight">Strategy:</span> Queue-based with full path in each element',
                        '<span class="algo-highlight">Memory:</span> High - stores complete path for each position',
                        '<span class="algo-highlight">Best for:</span> Simple implementation, educational purposes'
                    ]
                }
                ,
                'astar': {
                    title: 'A* - A* Search (Manhattan Heuristic)',
                    description: 'A* combines best-first search with a cost heuristic to efficiently find short paths. We use Manhattan distance as the heuristic.',
                    features: [
                        '<span class="algo-highlight">Guarantees shortest path:</span> Yes if the heuristic is admissible (Manhattan is admissible for 4-directional grids)',
                        '<span class="algo-highlight">Strategy:</span> Priority queue (min-heap) ordered by f = g + h',
                        '<span class="algo-highlight">Memory:</span> Moderate to high depending on explored nodes',
                        '<span class="algo-highlight">Best for:</span> Fast optimal pathfinding on grids with Manhattan distance'
                    ]
                }
                ,
                'random': {
                    title: 'Random Greedy - Greedy Best-First (Manhattan + random tie-break)',
                    description: 'Greedy best-first search guided by the Manhattan heuristic. When multiple nodes have the same heuristic value, the algorithm breaks ties randomly to produce varied paths.',
                    features: [
                        '<span class="algo-highlight">Guarantees shortest path:</span> Not guaranteed (heuristic-only), may find short paths quickly',
                        '<span class="algo-highlight">Strategy:</span> Priority queue ordered by h (Manhattan); ties broken randomly',
                        '<span class="algo-highlight">Memory:</span> Moderate - stores open set and came-from map',
                        '<span class="algo-highlight">Best for:</span> Fast, exploratory search where varied solutions are interesting'
                    ]
                }
            };
            
            let cellsExplored = 0;
            let searchStartTime = 0;
            const timeDisplay = document.getElementById('time_ms');

            function showSearchResults() {
                const duration = Date.now() - searchStartTime;
                timeDisplay.innerText = duration;
                const solutionLength = maze.flat().filter(cell => cell === 7).length;
                // include discovered (8) as explored/discovered for counting
                const exploredCells = maze.flat().filter(cell => cell === 4 || cell === 5 || cell === 7 || cell === 8).length;
                solutionLengthNumber.innerText = solutionLength;
                cellsExploredDisplay.innerText = exploredCells;
                resultsPane.style.display = 'flex';
                // Reset start button text and disable it until user generates a new maze or clears search
                startButton.textContent = 'Start Search';
                startButton.disabled = true;
            }

            function finishSearch() {
                // shared UI updates when a search finishes (success or failure)
                isSearching = false;
                startButton.textContent = 'Start Search';
                startButton.disabled = true; // disabled until user generates/clears
                stopButton.disabled = true;
                resetSearchButton.disabled = false;
                resetButton.disabled = false; // alias to generate maze button
            }


            // --- Constants ---
            const WALL_COLOR = 'black';         //0
            const PATH_COLOR = 'white';         //1
            const START_COLOR = 'cyan';         //2
            const END_COLOR = 'lightgreen';          //3
            const EXPLORED_COLOR = 'yellow';    //4
            const BACKTRACK_COLOR = 'pink';     //5
            const CURRENT_COLOR = 'purple';     //6
            const SOLUTION_COLOR = 'red';       //7
            const BORDER_COLOR = 'lightblue';   //8
            //
            const CELL_SIZE = 10;

            // --- Global Variables ---
            let maze = [];
            let canvasWidth = parseInt(heightSlider.value * CELL_SIZE);
            let canvasHeight = parseInt(heightSlider.value * CELL_SIZE);
            let speed = parseInt(speedSlider.value);
            let mode = modeSelector.value;  // 'bfs' or 'dfs'
            let isSearching = false;
            let animationFrameId;
            let startCell;
            let endCell;

            // --- Canvas Setup ---
            const ctx = mazeCanvas.getContext('2d'); // returns an object that provides methods and properties for drawing on the canvas
            mazeCanvas.width = canvasWidth;
            mazeCanvas.height = canvasHeight;

            // --- Functions ---



            /**
              * Generates a maze using Fractal Tessellation algorithm.
              * @param {number[][]} maze - The maze grid to modify.
              * @param {number} rows - Number of rows in the maze.
              * @param {number} cols - Number of columns in the maze.
              */
            function generateMaze() {

                let rows = Math.floor(ctx.canvas.width / CELL_SIZE);
                let cols = Math.floor(ctx.canvas.height / CELL_SIZE);
                //if rows is even, add 1
                if (rows % 2 === 0) {
                    rows--;
                }
                //if cols is even, add 1
                if (cols % 2 === 0) {
                    cols--;
                }



                // Create initial 3x3 maze
                maze = [
                    [0, 0],
                    [0, 1]
                ];

                // Initialize the rest of the maze with the initial 2x2 maze
                for (let i = 0; i < 2; i++) {
                    for (let j = 2; j < cols; j++) {
                        maze[i].push(maze[i % 2][j % 2]);
                    }
                }
                for (let i = 2; i < rows; i++) {
                    maze.push([]);
                    for (let j = 0; j < cols; j++) {
                        maze[i].push(maze[i % 2][j % 2]);
                    }
                }

                // close the maze
                maze.forEach(element => {
                    element[element.length - 1] = 0;
                });

                maze[maze.length - 1].fill(0);





                // for every 2x2 cell in the maze
                for (let i = 0; i < maze.length; i++) {
                    for (let j = 0; j < maze[i].length; j++) {
                        if (i !== 0 && j !== 0 && i !== maze.length - 1 && j !== maze[i].length - 1) {
                            // si alrededor de i,j hay muchas paredes entonces no se pone una pared

                            let WALL_PROBABILITY = 25 - countWallsAround(i, j, 2);

                            if (i % 2 === 1) {
                                if (Math.floor(Math.random() * 25) > WALL_PROBABILITY) {
                                    maze[i][j] = 1;
                                }
                            }
                            if (j % 2 === 1) {
                                if (Math.floor(Math.random() * 25) > WALL_PROBABILITY) {
                                    maze[i][j] = 1; // 1 means no wall
                                }
                            }

                        }
                    }
                }

                // Post-process: for every non-border cell that is white (1) and whose
                // four orthogonal neighbors are all walls (0), open one random
                // non-border neighbor (set it to white). This avoids isolated white
                // cells surrounded entirely by walls.
                for (let i = 1; i < maze.length - 1; i++) {
                    for (let j = 1; j < maze[i].length - 1; j++) {
                        if (maze[i][j] === 1) {
                            const neighbors = [
                                { r: i - 1, c: j },
                                { r: i + 1, c: j },
                                { r: i, c: j - 1 },
                                { r: i, c: j + 1 }
                            ];
                            // Check all four orthogonal neighbors are walls (0)
                            const allWalls = neighbors.every(n => maze[n.r][n.c] === 0);
                            if (allWalls) {
                                // Choose among orthogonal neighbors that are strictly interior (not on border)
                                const candidates = neighbors.filter(n => n.r > 0 && n.r < maze.length - 1 && n.c > 0 && n.c < maze[0].length - 1);
                                if (candidates.length > 0) {
                                    const pick = candidates[Math.floor(Math.random() * candidates.length)];
                                    maze[pick.r][pick.c] = 1; // open that neighbor
                                }
                            } else {
                                // Additionally, check the 8 surrounding cells (including diagonals).
                                // If exactly 7 of the 8 neighbors are walls (0), open a random
                                // orthogonal interior neighbor to avoid near-complete isolation.
                                const neigh8 = [
                                    { r: i - 1, c: j - 1 }, { r: i - 1, c: j }, { r: i - 1, c: j + 1 },
                                    { r: i, c: j - 1 },                       { r: i, c: j + 1 },
                                    { r: i + 1, c: j - 1 }, { r: i + 1, c: j }, { r: i + 1, c: j + 1 }
                                ];
                                let wallCount = 0;
                                for (const n of neigh8) {
                                    if (n.r >= 0 && n.r < maze.length && n.c >= 0 && n.c < maze[0].length) {
                                        if (maze[n.r][n.c] === 0) wallCount++;
                                    } else {
                                        // treat out-of-bounds as walls
                                        wallCount++;
                                    }
                                }
                                if (wallCount === 7) {
                                    // pick a random orthogonal interior neighbor
                                    const ortho = neighbors.filter(n => n.r > 0 && n.r < maze.length - 1 && n.c > 0 && n.c < maze[0].length - 1);
                                    if (ortho.length > 0) {
                                        const pick2 = ortho[Math.floor(Math.random() * ortho.length)];
                                        maze[pick2.r][pick2.c] = 1;
                                    }
                                }
                            }
                        }
                    }
                }

            }

            function countWallsAround(i, j, d) {
                let walls = 0;
                for (let x = i - d; x <= i + d; x++) {
                    for (let y = j - d; y <= j + d; y++) {
                        if (x >= 0 && x < maze.length && y >= 0 && y < maze[x].length) {
                            if (maze[x][y] === 0) {
                                walls++;
                            }
                        }
                    }
                }
                return walls;
            }

            function generateOddRandomNumber(min, max) {
                num = Math.floor(Math.random() * (maze[0].length - 1));
                while (num % 2 === 0) {
                    num = Math.floor(Math.random() * (maze[0].length - 1));
                }
                return num;
            }

            function createEntryPoints() {
                let entryx, entryy, exitx, exity;
                // choose a random number between 0 and 12
                let random = Math.floor(Math.random() * 4);
                console.log(random);
                switch (random) {
                    case 0:
                        entryx = 0;
                        entryy = generateOddRandomNumber(0, maze.length - 1);
                        exitx = maze.length - 1;
                        exity = generateOddRandomNumber(0, maze[0].length - 1);
                        break;
                    case 1:
                        entryx = generateOddRandomNumber(0, maze.length - 1);
                        entryy = 0;
                        exitx = generateOddRandomNumber(0, maze.length - 1);
                        exity = maze[0].length - 1;
                        break;
                    case 2:
                        entryx = generateOddRandomNumber(0, maze.length - 1);
                        entryy = maze[0].length - 1;
                        exitx = generateOddRandomNumber(0, maze[0].length - 1);
                        exity = 0;
                        break;
                    case 3:
                        entryx = maze.length - 1;
                        entryy = generateOddRandomNumber(0, maze[0].length - 1);
                        exitx = 0;
                        exity = generateOddRandomNumber(0, maze.length - 1);
                        break;
                }
                console.log(entryx, entryy, exitx, exity);
                maze[entryx][entryy] = 2; // 2 means start
                maze[exitx][exity] = 3; // 3 means end
                makeSolvable(maze, entryx, entryy, exitx, exity);
            }

            function makeSolvable(maze, entryx, entryy, exitx, exity) {
                //repeat until maze is solvable
                let isSolvable = isMazeSolvable(maze, entryx, entryy, exitx, exity);
                while (!isSolvable) {
                    // take a random cell in the maze that is not in the borders of the maze
                    const randomRow = Math.floor(Math.random() * (maze.length - 2)) + 1;
                    const randomCol = Math.floor(Math.random() * (maze[0].length - 2)) + 1;

                    // Randomly remove walls
                    if (maze[randomRow][randomCol] === 0) {
                        // if the cell is 101, make it 1
                        if (maze[randomRow - 1][randomCol] === 1 || maze[randomRow + 1][randomCol] === 1) {
                            maze[randomRow][randomCol] = 1;
                        } else {
                            if (maze[randomRow][randomCol - 1] === 1 || maze[randomRow][randomCol + 1] === 1) {
                                maze[randomRow][randomCol] = 1;
                            }
                        }
                        maze[randomRow][randomCol] = 1;
                    }
                    // Check if the maze is solvable
                    isSolvable = isMazeSolvable(maze, entryx, entryy, exitx, exity);
                }
            }

            /**
             * Checks if the maze is solvable using BFS
             * @param {number[][]} maze The maze grid.
             * @param {number} startRow The starting row.
             * @param {number} startCol The starting column.
             * @param {number} endRow The ending row.
             * @param {number} endCol The ending column.
             * @returns boolean
             */
            function isMazeSolvable(maze, startRow, startCol, endRow, endCol) {
                const rows = maze.length;
                const cols = maze[0].length;
                const queue = [{ row: startRow, col: startCol }];
                const visited = Array(rows).fill(null).map(() => Array(cols).fill(false));

                visited[startRow][startCol] = true;

                while (queue.length > 0) {
                    const { row, col } = queue.shift();

                    if (row === endRow && col === endCol) {
                        return true; // Path found
                    }

                    const neighbors = [
                        { row: row - 1, col: col },
                        { row: row + 1, col: col },
                        { row: row, col: col - 1 },
                        { row: row, col: col + 1 },
                    ];

                    for (let neighbor of neighbors) {
                        const { row: nextRow, col: nextCol } = neighbor;
                        if (isValidCell(nextRow, nextCol, maze) && !visited[nextRow][nextCol]) {
                            visited[nextRow][nextCol] = true;
                            queue.push({ row: nextRow, col: nextCol });
                        }
                    }
                }
                return false; // No path found
            }



            /**
             * Dibuja el laberinto en el canvas.
             * @param {number[][]} maze - La cuadrícula del laberinto a dibujar.
             * @param {CanvasRenderingContext2D} ctx - El contexto de renderizado del canvas.
             * @param {number} cellSize - El tamaño de cada celda en píxeles.
             */
            function drawMaze(maze, ctx) {
                const cellSize = CELL_SIZE;
                const rows = maze.length;
                const cols = maze[0].length;

                //while (ctx.firstChild) {
                //    ctx.firstChild.remove();
                //}

                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); // Limpia el canvas

                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        switch (maze[i][j]) {
                            case 0: // Muro
                                ctx.fillStyle = WALL_COLOR;
                                break;
                            case 1: // Camino
                                ctx.fillStyle = PATH_COLOR;
                                break;
                            case 2: // Inicio
                                ctx.fillStyle = START_COLOR;
                                //ctx.strokeStyle = START_COLOR; // Borde doble
                                //ctx.lineWidth = 5;
                                break;
                            case 3: // Fin
                                ctx.fillStyle = END_COLOR;
                                //ctx.strokeStyle = END_COLOR;  // Borde doble
                                //ctx.lineWidth = 2;
                                break;
                            case 4: // Explorado
                                ctx.fillStyle = EXPLORED_COLOR;
                                break;
                            case 5: // Retroceso
                                ctx.fillStyle = BACKTRACK_COLOR;
                                break;
                            case 6: // Actual
                                ctx.fillStyle = CURRENT_COLOR;
                                break;
                            case 7: // Solucion
                                ctx.fillStyle = SOLUTION_COLOR;
                                break;
                            case 8: // exploring border
                                ctx.fillStyle = BORDER_COLOR;
                                break;
                        }
                        ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
                        /*
                        if (maze[i][j] === 2 || maze[i][j] === 3) { // Dibuja borde doble.
                            ctx.strokeRect(j * cellSize, i * cellSize, cellSize, cellSize);
                        }
                            */
                    }
                }
            }

            /**
             * Verifica si una celda es válida (dentro de los límites y es un camino).
             * @param {number} row - La fila de la celda.
             * @param {number} col - La columna de la celda.
             * @param {number[][]} maze - La cuadrícula del laberinto.
             * @returns {boolean} Verdadero si la celda es válida, falso en caso contrario.
             */
            function isValidCell(row, col, maze) {
                const rows = maze.length;
                const cols = maze[0].length;
                return row >= 0 && row < rows && col >= 0 && col < cols && (maze[row][col] === 1 || maze[row][col] === 3);
            }

            function setState(initialState = true) {
                if (initialState) {
                    startButton.disabled = true;
                    stopButton.disabled = true;
                    resetButton.disabled = true;
                    resetSearchButton.disabled = true;
                } else {
                    startButton.disabled = false;
                    stopButton.disabled = true;
                    resetButton.disabled = false;
                    resetSearchButton.disabled = false;
                }
            }

            /**
              * Solves maze using BFS algorithm
              * this approach uses a queue to explore all neighbors of the current cell
              * @param {number[][]} maze - La cuadrícula del laberinto a resolver.
              * @param {number} startRow - La fila de inicio.
              * @param {number} startCol - La columna de inicio.
              * @param {number} endRow - La fila de fin.
              * @param {number} endCol - La columna de fin.
              * @param {number} speed - La velocidad de la animación de búsqueda en milisegundos.
              */
            function solveMazeFLOOD(maze, startRow, startCol, endRow, endCol, speed) {                
                // initilize queue to store the path to the cells that are being explored
                const queue = [{ row: startRow, col: startCol, path: [{ row: startRow, col: startCol }] }];
                function animateSearch() {
                        if (queue.length === 0) { // stop condition: there are no more cells to explore
                        drawMaze(maze, ctx, CELL_SIZE);
                        setState(false);
                        finishSearch();
                        alert("No path found!");
                    } else {
                        const { row, col, path } = queue.shift(); // get the next cell to explore                        
                        if (row !== startRow && col !== startCol) { // if the cell is not the initial cell, mark it as explored
                            maze[row][col] = 6;  // mark the current cell
                            drawMaze(maze, ctx);
                        } else {
                            maze[row][col] = 2; // mark the start cell
                            drawMaze(maze, ctx, CELL_SIZE);
                        }
                        if (row === endRow && col === endCol) { // maze is solved: found the end cell
                            for (let p of path) { // mark the solution path
                                if (p.row !== startRow || p.col !== startCol) {
                                    if (p.row !== endRow || p.col !== endCol) {
                                        maze[p.row][p.col] = 7; // mark the solution path
                                    }
                                }
                            }
                            drawMaze(maze, ctx, CELL_SIZE);
                            setState(false);
                            showSearchResults();
                            finishSearch();
                            alert("Path found!");
                        } else { // if the cell is not the end cell, explore its neighbors
                            const neighbors = getNeighbors(row, col);
                            for (const neighbor of neighbors) {
                                const { row: nextRow, col: nextCol } = neighbor;
                                if (isValidCell(nextRow, nextCol, maze)) {
                                    const newPath = [...path, { row: nextRow, col: nextCol }];
                                    queue.push({ row: nextRow, col: nextCol, path: newPath });
                                    maze[nextRow][nextCol] = 8;
                                }
                            }
                            if (row !== startRow || col !== startCol) {
                                maze[row][col] = 4;
                            }
                            animationFrameId = setTimeout(animateSearch, speed);
                        }
                    }
                }
                animateSearch();
            }

            function getNeighbors(row, col) {
                return [
                    { row: row - 1, col: col }, // Arriba
                    { row: row + 1, col: col }, // Abajo
                    { row: row, col: col - 1 }, // Izquierda
                    { row: row, col: col + 1 }, // Derecha
                ];
            }

            /**
             * Resuelve el laberinto usando la Búsqueda en Profundidad (DFS).
             * @param {number[][]} maze - La cuadrícula del laberinto.
             * @param {number} startRow - Fila de inicio.
             * @param {number} startCol - Columna de inicio.
             * @param {number} endRow - Fila de fin.
             * @param {number} endCol - Columna de fin.
             * @param {number} speed - Velocidad de la animación en milisegundos.
             */
            function solveMazeDFS3(maze, startRow, startCol, endRow, endCol, speed) {
                const rows = maze.length;
                const cols = maze[0].length;
                const stack = [{ row: startRow, col: startCol, path: [{ row: startRow, col: startCol }] }];
                const visited = Array(rows).fill(null).map(() => Array(cols).fill(false));

                visited[startRow][startCol] = true;
                maze[startRow][startCol] = 6; // Marca la celda actual

                function animateSearch() {
                        if (stack.length === 0 || isSearching === false) {
                            finishSearch();
                            alert("No path found!");
                            maze[startRow][startCol] = 2;
                            drawMaze(maze, ctx, CELL_SIZE);
                        return;
                    }

                    const { row, col, path } = stack.pop();
                    // mark processed node (if not start/end)
                    if (!(row === startRow && col === startCol) && !(row === endRow && col === endCol)) {
                        maze[row][col] = 4; // processed
                    }
                    drawMaze(maze, ctx, CELL_SIZE);

                    if (row === endRow && col === endCol) {
                        // Se ha encontrado el final
                        maze[startRow][startCol] = 2;
                        maze[endRow][endCol] = 3;
                        for (let p of path) {
                            maze[p.row][p.col] = 4; // Marca el camino
                        }
                        drawMaze(maze, ctx, CELL_SIZE);
                        // finalize UI and show results
                        showSearchResults();
                        finishSearch();
                        alert("Path found!");
                        return;
                    }

                    const neighbors = [
                        { row: row - 1, col: col }, // Arriba
                        { row: row + 1, col: col }, // Abajo
                        { row: row, col: col - 1 }, // Izquierda
                        { row: row, col: col + 1 }, // Derecha
                    ];

                    // if all neighbors are walls, or visited cells, or backtrack cells, backtrack
                    let allWalls = true;
                    for (const neighbor of neighbors) {
                        const { row: nextRow, col: nextCol } = neighbor;
                        if (isValidCell(nextRow, nextCol, maze) && !visited[nextRow][nextCol]) {
                            allWalls = false;
                            break;
                        }
                    }
                    if (allWalls) {
                        maze[row][col] = 5; // Marca la celda como retroceso
                        drawMaze(maze, ctx, CELL_SIZE);
                        if (stack.length === 0) {
                            // no more nodes and no path
                            finishSearch();
                            alert("No path found!");
                        }
                    } else {
                        for (const neighbor of neighbors) {
                            const { row: nextRow, col: nextCol } = neighbor;
                            if (isValidCell(nextRow, nextCol, maze) && !visited[nextRow][nextCol]) {
                                visited[nextRow][nextCol] = true;
                                const newPath = [...path, { row: nextRow, col: nextCol }];
                                stack.push({ row: nextRow, col: nextCol, path: newPath });
                                animationFrameId = setTimeout(animateSearch, speed);
                                if (isSearching) {

                                    maze[nextRow][nextCol] = 6; // Marca la celda como actual
                                    drawMaze(maze, ctx, CELL_SIZE);

                                    // if all neighbors are walls, or visited cells, or backtrack cells, backtrack
                                    let allWalls = true;
                                    for (const neighbor of neighbors) {
                                        const { row: nextRow, col: nextCol } = neighbor;
                                        if (isValidCell(nextRow, nextCol, maze) && !visited[nextRow][nextCol]) {
                                            allWalls = false;
                                            break;
                                        }
                                    }
                                    if (allWalls) {
                                        maze[row][col] = 5; // Marca la celda como retroceso
                                        drawMaze(maze, ctx, CELL_SIZE);
                                        if (stack.length === 0) {
                                            finishSearch();
                                            alert("No path found!");
                                        }
                                        break;

                                    }



                                } else {
                                    break; // Salir del bucle si se ha detenido la búsqueda


                                }


                            }
                        }
                    }

                }
                animateSearch();
            }



            function solveMazeDFS(maze, startRow, startCol, endRow, endCol, speed) {
                const rows = maze.length;
                const cols = maze[0].length;
                const queue = [{ row: startRow, col: startCol, path: [{ row: startRow, col: startCol }] }];
                //const visited = Array(rows).fill(null).map(() => Array(cols).fill(false));
                //visited[startRow][startCol] = true;
                function animateSearch() {
                    // condición de parada
                            if (queue.length === 0 || !isSearching) {
                        maze[startRow][startCol] = 2;
                        maze[endRow][endCol] = 3;
                        drawMaze(maze, ctx, CELL_SIZE);
                        startButton.disabled = false;
                        stopButton.disabled = true;
                        resetButton.disabled = false;
                        resetSearchButton.disabled = false;
                        if (isSearching) {
                            isSearching = false;
                            alert("No path found!");
                        }

                    } else {

                        const { row, col, path } = queue.pop();

                        if (row !== startRow || col !== startCol) {
                            maze[row][col] = 6;  // Marca la celda actual
                        }

                        drawMaze(maze, ctx);

                        if (row === endRow && col === endCol) {
                            // Se ha encontrado el final
                            for (let p of path) {
                                if (p.row !== startRow || p.col !== startCol) {
                                    if (p.row !== endRow || p.col !== endCol) {
                                        maze[p.row][p.col] = 7; // Marca el camino encontrado
                                    }
                                }

                            }
                            maze[startRow][startCol] = 2;
                            maze[endRow][endCol] = 3;
                            drawMaze(maze, ctx, CELL_SIZE);
                            // finalize UI and show results
                            finishSearch();
                            showSearchResults();
                            alert("Path found!");
                        } else {

                            const neighbors = [
                                { row: row - 1, col: col }, // Arriba
                                { row: row + 1, col: col }, // Abajo
                                { row: row, col: col - 1 }, // Izquierda
                                { row: row, col: col + 1 }, // Derecha
                            ];
                            let sinsalida = true;
                            for (const neighbor of neighbors) {
                                const { row: nextRow, col: nextCol } = neighbor;

                                if (isValidCell(nextRow, nextCol, maze)) {
                                    const newPath = [...path, { row: nextRow, col: nextCol }];
                                    queue.push({ row: nextRow, col: nextCol, path: newPath });
                                    maze[nextRow][nextCol] = 8;
                                    animationFrameId = setTimeout(animateSearch, speed);
                                    sinsalida = false;
                                }
                            }
                            if (sinsalida) {
                                maze[row][col] = 5;
                            } else {
                                if (row !== startRow || col !== startCol) {
                                    maze[row][col] = 4;
                                }
                            }

                        }
                    }
                }
                animateSearch();
            }


            async function recursiveCall(f, maze, startRow, startCol, endRow, endCol, speed) {
                const result = await f(maze, startRow, startCol, endRow, endCol, speed);
                console.log(result); // --> 'done!';
                return result;
            }


            //function solveMazeDFS2(maze, startRow, startCol, endRow, endCol, speed, ctx, CELL_SIZE, drawMaze, startButton, stopButton, resetButton, resetSearchButton) {
            function solveMazeDFS2(maze, startRow, startCol, endRow, endCol, speed) {

                let animationFrameId = null;


                function animateSearch(row, col) {
                    return new Promise((resolve) => {
                        if (row === endRow && col === endCol) {
                            maze[row][col] = 3; // Mark the end as part of the path
                            drawMaze(maze, ctx, CELL_SIZE);
                            resolve(1);
                            return; // Important: Exit the function!
                        } else {
                            const neighbors = [
                                { row: row - 1, col: col }, // Arriba
                                { row: row + 1, col: col }, // Abajo
                                { row: row, col: col - 1 }, // Izquierda
                                { row: row, col: col + 1 }, // Derecha
                            ];
                            maze[row][col] = 4; // Mark the current cell as visited/exploring
                            drawMaze(maze, ctx, CELL_SIZE);

                            function processNeighbors(index) { // Helper function for sequential processing
                                if (index < neighbors.length) {
                                    const { row: nextRow, col: nextCol } = neighbors[index];
                                    if (isValidCell(nextRow, nextCol, maze)) {
                                        animationFrameId = setTimeout(() => {
                                            animateSearch(nextRow, nextCol).then(result => {
                                                if (result > 0) {
                                                    maze[row][col] = 7; // Mark the current cell as part of the path
                                                    drawMaze(maze, ctx, CELL_SIZE);
                                                    resolve(++result);
                                                } else {
                                                    maze[row][col] = 5; // Mark the current cell as backtrack
                                                    drawMaze(maze, ctx, CELL_SIZE);
                                                    processNeighbors(index + 1); // Continue with the next neighbor
                                                }
                                            });
                                        }, speed);
                                    } else {
                                        processNeighbors(index + 1); // Move to the next neighbor if the current one is not valid
                                    }
                                } else {
                                    // After checking all neighbors, if none lead to the solution
                                    if (!maze.flat().includes(3)) {
                                        maze[row][col] = 5;
                                        drawMaze(maze, ctx, CELL_SIZE);
                                    }
                                    resolve(0); // No path found from this cell
                                }
                            }
                            processNeighbors(0); // Start processing neighbors
                        }
                    });
                }

                async function startSolving() {
                    startButton.disabled = true;
                    stopButton.disabled = false;
                    resetButton.disabled = true;
                    resetSearchButton.disabled = true;
                    const len = await animateSearch(startRow, startCol); // Wait for the search to complete
                    maze[startRow][startCol] = 2;
                    maze[endRow][endCol] = 3;
                    drawMaze(maze, ctx, CELL_SIZE);
                    // finalize UI: if no solution found, call finishSearch(); otherwise show results and finish
                    if (!len && !maze.flat().includes(3)) {
                        finishSearch();
                        console.log("No solution found.");
                    } else {
                        // Calculate and display results
                        const solutionLength = maze.flat().filter(cell => cell === 7).length;
                        const exploredCells = maze.flat().filter(cell => cell === 4 || cell === 5 || cell === 7).length;
                        solutionLengthNumber.innerText = solutionLength;
                        cellsExploredDisplay.innerText = exploredCells;
                        resultsPane.style.display = "flex";
                        showSearchResults();
                        finishSearch();
                    }
                }

                startSolving();
            }


            //function solveMazeBFS(maze, startRow, startCol, endRow, endCol, speed, ctx, CELL_SIZE, drawMaze, startButton, stopButton, resetButton, resetSearchButton) {
            function solveMazeBFS3(maze, startRow, startCol, endRow, endCol, speed) {
                let animationFrameId = null;



                function animateSearch() {
                    return new Promise((resolve) => {
                        let queue = [{ row: startRow, col: startCol, path: [{ row: startRow, col: startCol }] }];
                        let visited = { [startRow + ',' + startCol]: true };

                        const exploreNext = () => {
                            if (queue.length === 0) {
                                // No solution found
                                finishSearch();
                                resolve(false);
                                return;
                            }

                            let { row, col, path } = queue.shift();
                            // mark the current node as processed (if not start/end)
                            if (!(row === startRow && col === startCol) && !(row === endRow && col === endCol)) {
                                maze[row][col] = 4; // processed / explored
                            }
                            drawMaze(maze, ctx, CELL_SIZE);

                            if (row === endRow && col === endCol) {
                                // Solution found!
                                for (let { row: pathRow, col: pathCol } of path) {
                                    maze[pathRow][pathCol] = 7; // Mark the path
                                }
                                maze[startRow][startCol] = 2;
                                maze[endRow][endCol] = 3;
                                drawMaze(maze, ctx, CELL_SIZE);
                                showSearchResults();
                                finishSearch();
                                resolve(true);
                                return;
                            }

                            const neighbors = [
                                { row: row - 1, col: col },
                                { row: row + 1, col: col },
                                { row: row, col: col - 1 },
                                { row: row, col: col + 1 },
                            ];

                            for (const neighbor of neighbors) {
                                const { row: nextRow, col: nextCol } = neighbor;
                                if (isValidCell(nextRow, nextCol, maze) && !visited[nextRow + ',' + nextCol]) {
                                    visited[nextRow + ',' + nextCol] = true;
                                    // mark as discovered
                                    if (!(nextRow === startRow && nextCol === startCol) && !(nextRow === endRow && nextCol === endCol)) {
                                        maze[nextRow][nextCol] = 8; // discovered
                                    }
                                    queue.push({ row: nextRow, col: nextCol, path: [...path, { row: nextRow, col: nextCol }] });
                                }
                            }

                            animationFrameId = setTimeout(exploreNext, speed); // Continue exploring
                        };

                        exploreNext(); // Start the exploration
                    });
                }

                async function startSolving() {
                    startButton.disabled = true;
                    stopButton.disabled = false;
                    resetButton.disabled = true;
                    resetSearchButton.disabled = true;
                    maze[startRow][startCol] = 2;
                    maze[endRow][endCol] = 3;
                    drawMaze(maze, ctx, CELL_SIZE);
                    const solved = await animateSearch(); // Wait for the search to complete

                    if (!solved && !maze.flat().includes(3)) {
                        console.log("No solution found.");
                        finishSearch();
                    } else if (solved) {
                        showSearchResults();
                        finishSearch();
                        alert('Path found!');
                    }
                }

                startSolving();
            }

            // A* search with Manhattan heuristic
            function manhattan(aRow, aCol, bRow, bCol) {
                return Math.abs(aRow - bRow) + Math.abs(aCol - bCol);
            }

            function solveMazeAStar(maze, startRow, startCol, endRow, endCol, speed) {
                // We'll implement a simple priority queue using an array and sort for simplicity
                const rows = maze.length;
                const cols = maze[0].length;
                const openSet = [];
                const cameFrom = {};
                const gScore = Array(rows).fill(null).map(() => Array(cols).fill(Infinity));
                const fScore = Array(rows).fill(null).map(() => Array(cols).fill(Infinity));

                gScore[startRow][startCol] = 0;
                fScore[startRow][startCol] = manhattan(startRow, startCol, endRow, endCol);
                openSet.push({ row: startRow, col: startCol, f: fScore[startRow][startCol] });

                // use global animationFrameId so stop/pause works consistently

                function reconstructPath(current) {
                    const path = [];
                    let key = current.row + ',' + current.col;
                    while (key && cameFrom[key]) {
                        const [r, c] = key.split(',').map(Number);
                        path.push({ row: r, col: c });
                        key = cameFrom[key];
                    }
                    path.push({ row: startRow, col: startCol });
                    return path.reverse();
                }

                function step() {
                    if (openSet.length === 0 || isSearching === false) {
                        // no path or stopped
                        if (isSearching) {
                            alert('No path found!');
                        }
                        finishSearch();
                        return;
                    }

                    // sort openSet by f ascending (small size so OK)
                    openSet.sort((a, b) => a.f - b.f);
                    const current = openSet.shift();
                    const { row, col } = current;

                    // mark current for visualization (don't overwrite start/end)
                    if (!(row === startRow && col === startCol) && !(row === endRow && col === endCol)) {
                        maze[row][col] = 6; // current
                    }
                    drawMaze(maze, ctx, CELL_SIZE);

                    if (row === endRow && col === endCol) {
                        // found
                        const path = reconstructPath({ row, col });
                        for (let p of path) {
                            if (!(p.row === startRow && p.col === startCol) && !(p.row === endRow && p.col === endCol)) {
                                maze[p.row][p.col] = 7;
                            }
                        }
                        drawMaze(maze, ctx, CELL_SIZE);
                        showSearchResults();
                        finishSearch();
                        alert('Path found!');
                        return;
                    }

                    // neighbors
                    const neighbors = [
                        { row: row - 1, col: col },
                        { row: row + 1, col: col },
                        { row: row, col: col - 1 },
                        { row: row, col: col + 1 },
                    ];

                    for (const n of neighbors) {
                        const nr = n.row;
                        const nc = n.col;
                        if (!isValidCell(nr, nc, maze) && !(nr === endRow && nc === endCol)) continue;
                        const tentativeG = gScore[row][col] + 1;
                        if (tentativeG < gScore[nr][nc]) {
                            cameFrom[nr + ',' + nc] = row + ',' + col;
                            gScore[nr][nc] = tentativeG;
                            fScore[nr][nc] = tentativeG + manhattan(nr, nc, endRow, endCol);
                            // add to openSet if not present
                            if (!openSet.find(e => e.row === nr && e.col === nc)) {
                                openSet.push({ row: nr, col: nc, f: fScore[nr][nc] });
                                // mark as discovered
                                if (!(nr === startRow && nc === startCol) && !(nr === endRow && nc === endCol)) {
                                    maze[nr][nc] = 8; // exploring border
                                }
                            }
                        }
                    }

                    // mark current as explored (if not start/end)
                    if (!(row === startRow && col === startCol) && !(row === endRow && col === endCol)) {
                        maze[row][col] = 4;
                    }
                    animationFrameId = setTimeout(step, speed);
                }

                step();
            }

            // Random Greedy: greedy best-first with Manhattan heuristic and random tie-breaking
            function solveMazeRandomGreedy(maze, startRow, startCol, endRow, endCol, speed) {
                const rows = maze.length;
                const cols = maze[0].length;
                const openSet = [];
                const cameFrom = {};
                const visited = Array(rows).fill(null).map(() => Array(cols).fill(false));

                function pushOpen(row, col) {
                    const h = manhattan(row, col, endRow, endCol);
                    openSet.push({ row, col, h });
                }

                visited[startRow][startCol] = true;
                pushOpen(startRow, startCol);

                function reconstruct(current) {
                    const path = [];
                    let key = current.row + ',' + current.col;
                    while (key && cameFrom[key]) {
                        const [r, c] = key.split(',').map(Number);
                        path.push({ row: r, col: c });
                        key = cameFrom[key];
                    }
                    path.push({ row: startRow, col: startCol });
                    return path.reverse();
                }

                function step() {
                    if (openSet.length === 0 || isSearching === false) {
                        if (isSearching) alert('No path found!');
                        finishSearch();
                        return;
                    }

                    // choose the node(s) with minimal h
                    let minH = Math.min(...openSet.map(e => e.h));
                    const candidates = openSet.filter(e => e.h === minH);
                    // random tie-break among candidates
                    const chosen = candidates[Math.floor(Math.random() * candidates.length)];
                    // remove chosen from openSet (first occurrence)
                    const idx = openSet.findIndex(e => e.row === chosen.row && e.col === chosen.col && e.h === chosen.h);
                    if (idx >= 0) openSet.splice(idx, 1);

                    const { row, col } = chosen;

                    if (!(row === startRow && col === startCol) && !(row === endRow && col === endCol)) {
                        maze[row][col] = 6; // current
                    }
                    drawMaze(maze, ctx, CELL_SIZE);

                    if (row === endRow && col === endCol) {
                        const path = reconstruct({ row, col });
                        for (let p of path) {
                            if (!(p.row === startRow && p.col === startCol) && !(p.row === endRow && p.col === endCol)) {
                                maze[p.row][p.col] = 7;
                            }
                        }
                        drawMaze(maze, ctx, CELL_SIZE);
                        showSearchResults();
                        finishSearch();
                        alert('Path found!');
                        return;
                    }

                    const neighbors = [
                        { row: row - 1, col: col },
                        { row: row + 1, col: col },
                        { row: row, col: col - 1 },
                        { row: row, col: col + 1 },
                    ];

                    for (const n of neighbors) {
                        const nr = n.row;
                        const nc = n.col;
                        if (!isValidCell(nr, nc, maze) && !(nr === endRow && nc === endCol)) continue;
                        if (!visited[nr][nc]) {
                            visited[nr][nc] = true;
                            cameFrom[nr + ',' + nc] = row + ',' + col;
                            // mark discovered
                            if (!(nr === startRow && nc === startCol) && !(nr === endRow && nc === endCol)) {
                                maze[nr][nc] = 8;
                            }
                            pushOpen(nr, nc);
                        }
                    }

                    // mark processed
                    if (!(row === startRow && col === startCol) && !(row === endRow && col === endCol)) {
                        maze[row][col] = 4;
                    }

                    animationFrameId = setTimeout(step, speed);
                }

                step();
            }



            function solveMazeDFS22(maze, startRow, startCol, endRow, endCol, speed) {
                function animateSearch(row, col, speed) {
                    if (row === endRow && col === endCol) {
                        return true;
                    } else {
                        const neighbors = [
                            { row: row - 1, col: col }, // Arriba
                            { row: row + 1, col: col }, // Abajo
                            { row: row, col: col - 1 }, // Izquierda
                            { row: row, col: col + 1 }, // Derecha
                        ];
                        let allWalls = true;
                        for (const neighbor of neighbors) {
                            const { row: nextRow, col: nextCol } = neighbor;
                            if (isValidCell(nextRow, nextCol, maze)) {
                                allWalls = false;
                                break;
                            }
                        }
                        //--
                        if (allWalls) {
                            if (row === startRow && col === startCol) {
                                return false;
                            } else {
                                maze[row][col] = 5; // Marks the cell as backtrack and ends
                                drawMaze(maze, ctx, CELL_SIZE);
                                return false;
                            }
                        } else {// no es el final y queda vecindario por explorar
                            for (const neighbor of neighbors) { // para cada vecino
                                const { row: nextRow, col: nextCol } = neighbor;
                                if (isValidCell(nextRow, nextCol, maze)) {
                                    maze[nextRow][nextCol] = 8;
                                    drawMaze(maze, ctx, CELL_SIZE);
                                    let result = false;
                                    animationFrameId = setTimeout(result = animateSearch(nextRow, nextCol), speed);
                                    //let result = animateSearch(nextRow, nextCol);
                                    if (result) {
                                        maze[nextRow][nextCol] = 7; // Marca el camino encontrado
                                        drawMaze(maze, ctx, CELL_SIZE);
                                        return true;
                                    } else {
                                        //maze[nextRow][nextCol] = 1; // Marca la celda como camino -> exponencial
                                        maze[nextRow][nextCol] = 5; // Marca la celda como retroceso                                        
                                        drawMaze(maze, ctx, CELL_SIZE);
                                    }

                                }
                            }
                            return false;
                        }
                    }
                }
                animateSearch(startRow, startCol);
                maze[startRow][startCol] = 2;
                maze[endRow][endCol] = 3;
                drawMaze(maze, ctx, CELL_SIZE);
                finishSearch();
            }







            function solveMazeBFS(maze, startRow, startCol, endRow, endCol, speed) {
                const rows = maze.length;
                const cols = maze[0].length;
                const stack = [{ row: startRow, col: startCol, path: [{ row: startRow, col: startCol }] }];
                const visited = Array(rows).fill(null).map(() => Array(cols).fill(false));

                visited[startRow][startCol] = true;
                maze[startRow][startCol] = 6; // Marca la celda actual

                function animateSearch() {
                    if (stack.length === 0 || isSearching === false) {
                        if (isSearching) {
                            alert("No path found!");
                        }
                        finishSearch();
                        maze[startRow][startCol] = 2;
                        drawMaze(maze, ctx, CELL_SIZE);
                        return;
                    }

                    const { row, col, path } = stack.pop();
                    maze[row][col] = 6; // Marca la celda actual
                    drawMaze(maze, ctx, CELL_SIZE);

                    if (row === endRow && col === endCol) {
                        // Se ha encontrado el final
                        maze[startRow][startCol] = 2;
                        maze[endRow][endCol] = 3;
                        for (let p of path) {
                            maze[p.row][p.col] = 4; // Marca el camino
                        }
                        drawMaze(maze, ctx, CELL_SIZE);
                        finishSearch();
                        showSearchResults();
                        alert("Path found!");
                        return;
                        return;
                    }

                    const neighbors = [
                        { row: row - 1, col: col }, // Arriba
                        { row: row + 1, col: col }, // Abajo
                        { row: row, col: col - 1 }, // Izquierda
                        { row: row, col: col + 1 }, // Derecha
                    ];

                    // if all neighbors are walls, or visited cells, or backtrack cells, backtrack
                    let allWalls = true;
                    for (const neighbor of neighbors) {
                        const { row: nextRow, col: nextCol } = neighbor;
                        if (isValidCell(nextRow, nextCol, maze) && !visited[nextRow][nextCol]) {
                            allWalls = false;
                            break;
                        }
                    }
                    if (allWalls) {
                        maze[row][col] = 5; // Marca la celda como retroceso
                        drawMaze(maze, ctx, CELL_SIZE);
                        if (stack.length === 0) {
                            isSearching = false;
                            startButton.disabled = false;
                            stopButton.disabled = true;
                            resetButton.disabled = false;
                            alert("No path found!");
                        }
                    } else {
                        for (const neighbor of neighbors) {
                            const { row: nextRow, col: nextCol } = neighbor;
                            if (isValidCell(nextRow, nextCol, maze) && !visited[nextRow][nextCol]) {
                                visited[nextRow][nextCol] = true;
                                // mark discovered
                                if (!(nextRow === startRow && nextCol === startCol) && !(nextRow === endRow && nextCol === endCol)) {
                                    maze[nextRow][nextCol] = 8; // discovered
                                }
                                const newPath = [...path, { row: nextRow, col: nextCol }];
                                stack.unshift({ row: nextRow, col: nextCol, path: newPath });
                                animationFrameId = setTimeout(animateSearch, speed);
                                if (isSearching) {

                                    maze[nextRow][nextCol] = 6; // Marca la celda como actual
                                    drawMaze(maze, ctx, CELL_SIZE);

                                    // if all neighbors are walls, or visited cells, or backtrack cells, backtrack
                                    let allWalls = true;
                                    for (const neighbor of neighbors) {
                                        const { row: nextRow, col: nextCol } = neighbor;
                                        if (isValidCell(nextRow, nextCol, maze) && !visited[nextRow][nextCol]) {
                                            allWalls = false;
                                            break;
                                        }
                                    }
                                    if (allWalls) {
                                        maze[row][col] = 5; // Marca la celda como retroceso
                                        drawMaze(maze, ctx, CELL_SIZE);
                                        if (stack.length === 0) {
                                            finishSearch();
                                            alert("No path found!");
                                        }
                                        break;

                                    }



                                } else {
                                    break; // Salir del bucle si se ha detenido la búsqueda


                                }


                            }
                        }
                    }

                }
                animateSearch();
            }





            /**
             * Resetea el laberinto y la búsqueda.
             */
            function resetMaze() {
                resultsPane.style.display = "none";
                cellsExplored = 0;
                isSearching = false;
                clearTimeout(animationFrameId);
                generateMaze();
                createEntryPoints();
                drawMaze(maze, ctx, CELL_SIZE);
                startButton.disabled = false;
                stopButton.disabled = true;
                resetButton.disabled = true;
                resetSearchButton.disabled = true;
                startButton.textContent = "Start Search";
            }

            // --- Listeners de Eventos ---

            // Update algorithm info display
            function updateAlgorithmInfo(algorithm) {
                const info = algorithmDescriptions[algorithm];
                if (info) {
                    algorithmInfo.innerHTML = `
                        <h3>${info.title}</h3>
                        <p>${info.description}</p>
                        <ul>
                            ${info.features.map(feature => `<li>${feature}</li>`).join('')}
                        </ul>
                    `;
                }
            }
            
            // Initialize with BFS info
            updateAlgorithmInfo('bfs');

            // Change maze size
            heightSlider.addEventListener('input', () => {
                canvasWidth = parseInt(heightSlider.value * CELL_SIZE);
                canvasHeight = parseInt(heightSlider.value * CELL_SIZE);
                const totalCells = Math.floor(canvasWidth / CELL_SIZE) * Math.floor(canvasHeight / CELL_SIZE);
                heightValueDisplay.textContent = `${totalCells} cells`;
                mazeCanvas.width = canvasWidth;
                mazeCanvas.height = canvasHeight;
                resetMaze();
            });

            // Change animation speed
            speedSlider.addEventListener('input', () => {
                speed = parseInt(speedSlider.value);
                speedValueDisplay.textContent = `${speed} ms`;
            });

            // Change search algorithm
            modeSelector.addEventListener('change', () => {
                mode = modeSelector.value;
                updateAlgorithmInfo(mode);
            });

            // Generate maze
            mazeCreationButton.addEventListener('click', () => {
                generateMaze();
                createEntryPoints();
                drawMaze(maze, ctx, CELL_SIZE);
                startButton.disabled = false;
                stopButton.disabled = true;
                resetButton.disabled = true;
                resetSearchButton.disabled = true;
                resultsPane.style.display = "none";
                startButton.textContent = "Start Search";
            });

            // Iniciar la búsqueda del camino
            startButton.addEventListener('click', () => {
                if (isSearching) return;
                // find start cell
                let startRow = 0;
                let startCol = 0;
                let endRow = 0;
                let endCol = 0;

                let foundStart = false;
                let foundEnd = false;

                for (let i = 0; i < maze.length; i++) {
                    for (let j = 0; j < maze[i].length; j++) {
                        if (maze[i][j] === 2) { // Encuentra la primera celda de camino como inicio
                            if (!foundStart) {
                                startRow = i;
                                startCol = j;
                                foundStart = true;
                                break;
                            }
                        }
                    }
                }

                for (let i = 0; i < maze.length; i++) {
                    for (let j = 0; j < maze[i].length; j++) {
                        if (maze[i][j] === 3) {
                            if (!foundEnd) {
                                endRow = i;
                                endCol = j;
                                foundEnd = true;
                                break;
                            }
                        }
                    }
                }

                if (!foundStart || !foundEnd) {
                    alert("Could not find valid start and end points in the maze.");
                    return;
                }

                cellsExplored = 0;
                resultsPane.style.display = "none";
                isSearching = true;
                startButton.disabled = true;
                stopButton.disabled = false;
                resetButton.disabled = true;
                resetSearchButton.disabled = true;
                startButton.textContent = "Searching...";
                searchStartTime = Date.now();

                if (mode === 'flood') {
                    solveMazeFLOOD(maze, startRow, startCol, endRow, endCol, speed);
                } else {
                    if (mode === 'bfs') {
                        solveMazeBFS3(maze, startRow, startCol, endRow, endCol, speed);
                    } else if (mode === 'dfs') {
                        solveMazeDFS2(maze, startRow, startCol, endRow, endCol, speed);
                    } else if (mode === 'astar') {
                        solveMazeAStar(maze, startRow, startCol, endRow, endCol, speed);
                    } else if (mode === 'random') {
                        solveMazeRandomGreedy(maze, startRow, startCol, endRow, endCol, speed);
                    }
                }
            });

            // Pause search
            stopButton.addEventListener('click', () => {
                isSearching = false;
                clearTimeout(animationFrameId);
                startButton.disabled = false;
                stopButton.disabled = true;
                resetButton.disabled = false;
                resetSearchButton.disabled = false;
                startButton.textContent = "Resume";
            });

            resetSearchButton.addEventListener('click', () => {
                // Reset maze cells to original state (keep walls, start, and end)
                for (let i = 0; i < maze.length; i++) {
                    for (let j = 0; j < maze[i].length; j++) {
                        if (maze[i][j] !== 0 && maze[i][j] !== 2 && maze[i][j] !== 3) {
                            maze[i][j] = 1;
                        }
                    }
                }
                isSearching = false;
                clearTimeout(animationFrameId);
                startButton.disabled = false;
                stopButton.disabled = true;
                resetButton.disabled = false;
                resultsPane.style.display = "none";
                startButton.textContent = "Start Search";
                drawMaze(maze, ctx, CELL_SIZE);
            });

            // Reset maze completely
            resetButton.addEventListener('click', () => {
                resetMaze();
            });

            // Initialize
            resetMaze();
        });
    </script>
</body>

</html>